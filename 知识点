强连通图的边最多n*(n-1) 最少n
连通图的边最多n*(n-1)/2 最少n

cout <<fixed<< setprecision(7) << ans <<endl;

栈优化 #pragma comment(linker, "/STACK:1024000000,1024000000")


首先要明确边双连通分量和点双连通分量的区别与联系
1.二者都是基于无向图
2.边双连通分量是删边后还连通，而后者是删点
3.点双连通分量一定是边双连通分量（除两点一线的特殊情况），反之不一定
4.点双连通分量可以有公共点，而边双连通分量不能有公共边
由于4，显然，求解边双连通分量只需先一遍dfs求桥，在一遍dfs求点（不经过桥即可）

long long 1e18

二进制为n个1 ，十进制表示为（1<< n）-1
如果要获得 n 的第 i 位的数据（0还是1），判断（n&（1<<i））,若真，为1，假，为0；
 //这里的第 i 位为从右往左从0开始数的
如果要设置 n 的第 i 位为1，n=（n |（1<<i））；                                                                             
如果要设置 n 的第 i 位为0，n=（n &（~（1<<i））；
如果要取出 n 的最后一个1 （lowbit）:（n &（-n））
(这里利用的是负数取反加1实际上改变的是二进制最低位的1这个性质)

shr:<< and:& xor:^ or:|
去掉最后一位          | (101101->10110)           | x shr 1
在最后加一个0         | (101101->1011010)         | x shl 1
在最后加一个1         | (101101->1011011)         | x shl 1+1
把最后一位变成1       | (101100->101101)          | x or 1
把最后一位变成0       | (101101->101100)          | x or 1-1
最后一位取反          | (101101->101100)          | x xor 1
把右数第k位变成1      | (101001->101101,k=3)      | x or (1 shl (k-1))
把右数第k位变成0      | (101101->101001,k=3)      | x and not(1 shl (k-1))
右数第k位取反         | (101001->101101,k=3)      | x xor (1 shl (k-1))
取末三位              | (1101101->101)            | x and 7
取末k位               | (1101101->1101,k=5)       | x and (1 shl k-1)
取右数第k位           | (1101101->1,k=4)          | x shr (k-1) and 1
把末k位变成1          | (101001->101111,k=4)      | x or (1 shl k-1)
末k位取反             | (101001->100110,k=4)      | x xor (1 shl k-1)
把右边连续的1变成0    | (100101111->100100000)    | x and (x+1)
把右起第一个0变成1    | (100101111->100111111)    | x or (x+1)
把右边连续的0变成1    | (11011000->11011111)      | x or (x-1)
取右边连续的1         | (100101111->1111)         | (x xor (x+1)) shr 1

STL中的nth_element()方法的使用 通过调用nth_element(start, start+n, end,cmpare)
方法可以使第n大元素处于第n位置（从0开始,其位置是下标为n的元素），复杂度为O(n)
并且比这个元素小的元素都排在这个元素之前，
比这个元素大的元素都排在这个元素之后，但不能保证他们是有序的
如果参数加入了compare函数，就按compare函数的方式比较

设A（n x n）为一个图的邻接矩阵，则a(i,j)表示两个点之间是否连通（1：连通，0：不连通）。
那么A的k次方中的每一个a（i，j）表示点i和j之间长度为k的路的条数
i++比++i慢
