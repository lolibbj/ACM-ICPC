#include<cstdio>
 #include<cstring>
 #include<queue>
 #include<cmath>
 using namespace std;
 const int maxn =1000+10;
 const int INF = 1e9;
 struct Edge{
     int u,v,c;
     int next;
 }edge[20*maxn];
 int n,m;
 int edn;//边数
 int p[maxn];//父亲
 int d[maxn];
 int sp,tp;//原点，汇点
 void addedge(int u,int v,int c)
 {
     edge[edn].u=u; edge[edn].v=v; edge[edn].c=c;
     edge[edn].next=p[u]; p[u]=edn++;
     edge[edn].u=v; edge[edn].v=u; edge[edn].c=0;
     edge[edn].next=p[v]; p[v]=edn++;
 }
 int bfs()
 {
     queue <int> q;
     memset(d,-1,sizeof(d));
     d[sp]=0;
     q.push(sp);
     while(!q.empty())
     {
         int cur=q.front();
         q.pop();
         for(int i=p[cur];i!=-1;i=edge[i].next)
         {
             int u=edge[i].v;
             if(d[u]==-1 && edge[i].c>0)
             {
                 d[u]=d[cur]+1;
                 q.push(u);
             }
         }
     }
     return d[tp] != -1;
 }
 int dfs(int a,int b)
 {
     int r=0;
     if(a==tp)return b;
     for(int i=p[a];i!=-1 && r<b;i=edge[i].next)
     {
         int u=edge[i].v;
         if(edge[i].c>0 && d[u]==d[a]+1)
         {
             int x=min(edge[i].c,b-r);
             x=dfs(u,x);
             r+=x;
             edge[i].c-=x;
             edge[i^1].c+=x;
         }
     }
     if(!r)d[a]=-2;
     return r;
 }

 int dinic(int sp,int tp)
 {
     int total=0,t;
     while(bfs())
     {
         while(t=dfs(sp,INF))
         total+=t;
     }
     return total;
 }
 int main()
 {
     int u,v,c,t,ca=0;
     scanf("%d",&t);
     while(t--)
     {
         ca++;
         scanf("%d%d",&m,&n);
         edn=0;//初始化
         memset(p,-1,sizeof(p));
         sp=1;tp=m;
         for(int i=0;i<n;i++)
         {
             scanf("%d%d%d",&u,&v,&c);
             addedge(u,v,c);
         }
         printf("Case %d: %d\n",ca,dinic(sp,tp));
     }
     return 0;
 }
